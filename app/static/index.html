<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø³Ø§Ø¹Ø¯ Ù…Ø¬Ù„Ø© Ø§Ù„Ø¯ÙˆØ­Ø© Ø§Ù„Ø°ÙƒÙŠ | Doha Magazine AI Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .message { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .typing-indicator { display: inline-block; }
        .typing-indicator span { animation: blink 1.4s infinite; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink { 0%, 60%, 100% { opacity: .2; } 30% { opacity: 1; } }
        
        /* Disabled input styles */
        #message-input:disabled {
            background-color: #f3f4f6;
            color: #6b7280;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        #send-button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="min-h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-gradient-to-r from-blue-600 to-blue-800 text-white p-4 shadow-lg">
            <div class="container mx-auto flex justify-between items-center">
                <h1 class="text-2xl font-bold">Ù…Ø³Ø§Ø¹Ø¯ Ù…Ø¬Ù„Ø© Ø§Ù„Ø¯ÙˆØ­Ø© Ø§Ù„Ø°ÙƒÙŠ</h1>
                <div class="flex items-center gap-4"></div>
            </div>
        </header>

        <!-- Main Chat Container -->
        <main class="flex-1 container mx-auto p-4 max-w-4xl">
            <!-- Welcome Message -->
            <div id="welcome" class="bg-white rounded-lg shadow-md p-6 mb-4">
                <h2 class="text-xl font-semibold mb-2">Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…Ø³Ø§Ø¹Ø¯ Ù…Ø¬Ù„Ø© Ø§Ù„Ø¯ÙˆØ­Ø© Ø§Ù„Ø°ÙƒÙŠ!</h2>
                <p class="text-gray-600 mb-2">Ø£Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯ Ù…ØªØ®ØµØµ ÙÙŠ Ù…Ø­ØªÙˆÙ‰ Ù…Ø¬Ù„Ø© Ø§Ù„Ø¯ÙˆØ­Ø© Ø§Ù„Ø«Ù‚Ø§ÙÙŠØ©. ÙŠÙ…ÙƒÙ†Ù†ÙŠ:</p>
                <ul class="text-gray-600 list-disc list-inside mb-2">
                    <li>Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­ÙŠØ§Øª ÙˆØ§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¨Ø³ÙŠØ·Ø©</li>
                    <li>Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ù‚Ø§Ù„Ø§Øª Ø§Ù„Ø£Ø¯Ø¨ÙŠØ© ÙˆØ§Ù„Ø«Ù‚Ø§ÙÙŠØ©</li>
                    <li>Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø­ÙˆØ§Ø±Ø§Øª Ù…Ø¹ Ø§Ù„ÙƒØªÙ‘Ø§Ø¨ ÙˆØ§Ù„Ù…ÙÙƒØ±ÙŠÙ†</li>
                    <li>ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª ÙˆØ§Ù„Ø¯Ø±Ø§Ø³Ø§Øª Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©</li>
                    <li>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù† Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹ Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø£Ø¯Ø¨ Ø§Ù„Ø¹Ø±Ø¨ÙŠ</li>
                </ul>
                <p class="text-blue-600 font-semibold">Ø£ØªØ­Ø¯Ø« Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙÙ‚Ø· - ÙŠØ±Ø¬Ù‰ Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù„Ù„Ø§Ø³ØªÙØ§Ø¯Ø© Ù…Ù† Ø®Ø¯Ù…Ø§ØªÙŠ.</p>
            </div>

            <!-- Chat Messages -->
            <div id="chat-container" class="space-y-4 mb-4 min-h-[400px]">
                <!-- Messages will be inserted here -->
            </div>


            <!-- Typing Indicator -->
            <div id="typing" class="hidden message bg-gray-100 rounded-lg p-4 mb-4">
                <div class="typing-indicator">
                    <span class="inline-block w-2 h-2 bg-gray-500 rounded-full"></span>
                    <span class="inline-block w-2 h-2 bg-gray-500 rounded-full mx-1"></span>
                    <span class="inline-block w-2 h-2 bg-gray-500 rounded-full"></span>
                </div>
            </div>
        </main>

        <!-- Input Area (Fixed at bottom) -->
        <div class="bg-white border-t shadow-lg">
            <div class="container mx-auto p-4 max-w-4xl">
                <form id="chat-form" class="flex gap-2 items-center">
                    <input 
                        type="text" 
                        id="message-input" 
                        placeholder="Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø§ÙƒØªØ¨ Ø³Ø¤Ø§Ù„Ùƒ Ø£Ùˆ ØªØ­ÙŠØªÙƒ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©..."
                        class="flex-1 border border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                    />
                    <button type="button" id="mic-button" title="ØªØ³Ø¬ÙŠÙ„ ØµÙˆØªÙŠ" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-3 rounded-lg">
                        ğŸ¤
                    </button>
                    <button 
                        type="submit" 
                        id="send-button"
                        class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                    >
                        Ø¥Ø±Ø³Ø§Ù„
                    </button>
                </form>
                <div id="recording-controls" class="mt-2 hidden">
                    <span id="recording-indicator" class="text-red-600 font-semibold">â— Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...</span>
                    <div class="inline-flex gap-2 ml-3">
                        <button type="button" id="send-recording" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„</button>
                        <button type="button" id="delete-recording" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded">Ø­Ø°Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Validate session ID format
        function isValidSessionId(sessionId) {
            if (!sessionId) return false;
            // Check if it's a valid UUID format
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return uuidRegex.test(sessionId);
        }

        // Always start a NEW session on page load (no reuse)
        let sessionId = generateUUID();
        localStorage.setItem('doha_chat_session_id', sessionId);
        console.log('Generated NEW session ID on page load:', sessionId);
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const chatForm = document.getElementById('chat-form');
        const micButton = document.getElementById('mic-button');
        const recordingControls = document.getElementById('recording-controls');
        const sendRecordingBtn = document.getElementById('send-recording');
        const deleteRecordingBtn = document.getElementById('delete-recording');
        const typingIndicator = document.getElementById('typing');
        const welcome = document.getElementById('welcome');
        
        // Processing flag to prevent multiple submissions
        let isProcessing = false;
        // WAV recording state
        let audioContext = null;
        let mediaStream = null;
        let sourceNode = null;
        let scriptNode = null;
        let recordedFloatChunks = []; // Float32 chunks (mono)
        let inputSampleRate = 44100;
        let hasRecording = false;
        function mergeFloat32Arrays(chunks, totalLength) {
            const result = new Float32Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
                result.set(chunk, offset);
                offset += chunk.length;
            }
            return result;
        }

        function downsampleTo16kHz(float32Data, sourceRate) {
            const targetRate = 16000;
            if (sourceRate === targetRate) return float32Data;
            const ratio = sourceRate / targetRate;
            const newLength = Math.round(float32Data.length / ratio);
            const result = new Float32Array(newLength);
            let idx = 0;
            let i = 0;
            while (idx < newLength) {
                const next = Math.round((idx + 1) * ratio);
                // Average (simple low-pass) across the window
                let sum = 0;
                let count = 0;
                for (; i < next && i < float32Data.length; i++) {
                    sum += float32Data[i];
                    count++;
                }
                result[idx] = count ? (sum / count) : 0;
                idx++;
            }
            return result;
        }

        function encodeWavPCM16(float32Data, sampleRate) {
            const buffer = new ArrayBuffer(44 + float32Data.length * 2);
            const view = new DataView(buffer);

            function writeString(offset, str) {
                for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
            }

            // RIFF header
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + float32Data.length * 2, true);
            writeString(8, 'WAVE');

            // fmt chunk
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // PCM chunk size
            view.setUint16(20, 1, true);  // PCM format
            view.setUint16(22, 1, true);  // mono
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true); // byte rate = sr * channels * bytesPerSample
            view.setUint16(32, 2, true);  // block align = channels * bytesPerSample
            view.setUint16(34, 16, true); // bits per sample

            // data chunk
            writeString(36, 'data');
            view.setUint32(40, float32Data.length * 2, true);

            // PCM conversion
            let offset = 44;
            for (let i = 0; i < float32Data.length; i++, offset += 2) {
                // clamp
                let s = Math.max(-1, Math.min(1, float32Data[i]));
                // scale to 16-bit signed int
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        async function startWavRecording() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaStream = stream;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            inputSampleRate = audioContext.sampleRate;
            sourceNode = audioContext.createMediaStreamSource(stream);
            scriptNode = audioContext.createScriptProcessor(4096, 1, 1);
            recordedFloatChunks = [];
            scriptNode.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                // copy to avoid referencing the same buffer
                recordedFloatChunks.push(new Float32Array(input));
            };
            sourceNode.connect(scriptNode);
            scriptNode.connect(audioContext.destination);
            recordingControls.classList.remove('hidden');
            document.getElementById('recording-indicator').textContent = 'â— Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...';
            micButton.textContent = 'â¸ï¸';
        }

        function stopWavRecording() {
            if (scriptNode) scriptNode.disconnect();
            if (sourceNode) sourceNode.disconnect();
            if (audioContext) audioContext.close();
            if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
            hasRecording = recordedFloatChunks.length > 0;
            recordingControls.classList.remove('hidden');
            document.getElementById('recording-indicator').textContent = 'ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ù‚Ø·Ø¹. ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„Ù‡ Ø£Ùˆ Ø­Ø°ÙÙ‡';
            micButton.textContent = 'ğŸ¤';
        }

        // Toggle recording on mic button click (WAV path)
        micButton.addEventListener('click', async () => {
            try {
                if (!audioContext || (audioContext && audioContext.state === 'closed')) {
                    await startWavRecording();
                } else {
                    stopWavRecording();
                }
            } catch (err) {
                console.error('Mic error:', err);
                alert('Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†.');
            }
        });

        // Delete current recording
        deleteRecordingBtn.addEventListener('click', () => {
            recordedFloatChunks = [];
            hasRecording = false;
            recordingControls.classList.add('hidden');
            document.getElementById('recording-indicator').textContent = '';
        });

        // Send recording to STT and then to chat
        sendRecordingBtn.addEventListener('click', async () => {
            if (!hasRecording || recordedFloatChunks.length === 0) {
                alert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ³Ø¬ÙŠÙ„ Ù„Ø¥Ø±Ø³Ø§Ù„Ù‡.');
                return;
            }
            try {
                // Merge and resample to 16k mono, then encode WAV
                const totalLength = recordedFloatChunks.reduce((a, c) => a + c.length, 0);
                const merged = mergeFloat32Arrays(recordedFloatChunks, totalLength);
                const resampled = downsampleTo16kHz(merged, inputSampleRate);
                const blob = encodeWavPCM16(resampled, 16000);
                const formData = new FormData();
                formData.append('audio', blob, 'recording.wav');
                const sttResp = await fetch('/api/stt', { method: 'POST', body: formData });
                if (!sttResp.ok) {
                    const errText = await sttResp.text();
                    throw new Error(errText);
                }
                const { text } = await sttResp.json();
                if (text && text.trim()) {
                    messageInput.value = text.trim();
                    // Auto-submit like typing then pressing send
                    chatForm.requestSubmit();
                } else {
                    alert('Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø£ÙŠ ÙƒÙ„Ø§Ù… Ù…Ù† Ø§Ù„ØªØ³Ø¬ÙŠÙ„.');
                }
            } catch (e) {
                console.error('STT error:', e);
                const msg = (e && e.message) ? e.message : 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØª Ø¥Ù„Ù‰ Ù†Øµ';
                alert(msg);
            } finally {
                // Reset recording UI
                recordedFloatChunks = [];
                hasRecording = false;
                recordingControls.classList.add('hidden');
            }
        });
        
        // Prevent Enter key submission while processing
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && isProcessing) {
                e.preventDefault();
                console.log('Processing in progress, ignoring Enter key');
            }
        });

        // Load existing feedback for messages
        function loadExistingFeedback() {
            console.log('Loading existing feedback for messages...');
            const messageElements = document.querySelectorAll('.message');
            
            messageElements.forEach((msgElement, index) => {
                const feedbackDiv = msgElement.querySelector('.mt-3.pt-3.border-t');
                if (feedbackDiv) {
                    const buttons = feedbackDiv.querySelectorAll('button');
                    buttons.forEach(button => {
                        const onclick = button.getAttribute('onclick');
                        if (onclick) {
                            // Extract message ID from onclick
                            const match = onclick.match(/submitFeedback\('([^']+)',\s*'([^']+)',\s*'([^']+)'\)/);
                            if (match) {
                                const [, sessionId, messageId, rating] = match;
                                // Check if this message already has feedback
                                // This would require a server call to get existing feedback
                                // For now, we'll just ensure the buttons are properly styled
                            }
                        }
                    });
                }
            });
        }

        // Add message to chat
        function addMessage(role, text, sources = [], messageId = null, feedback = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role === 'user' ? 'text-right' : 'text-left'}`;
            
            const bubble = document.createElement('div');
            bubble.className = `inline-block max-w-3xl p-4 rounded-lg ${
                role === 'user' 
                    ? 'bg-blue-600 text-white' 
                    : 'bg-white shadow-md text-gray-800'
            }`;
            
            // Format text (handle markdown-like formatting)
            const formattedText = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                                      .replace(/\n/g, '<br>');
            bubble.innerHTML = formattedText;
            
           
            
            // Add feedback buttons to ALL assistant responses
            if (role === 'assistant' && messageId) {
                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'mt-3 pt-3 border-t border-gray-200 flex gap-2 items-center';
                
                // Show current feedback status
                const upButtonClass = feedback === 'up' ? 'bg-green-600 text-white font-semibold' : 'text-green-600 hover:text-green-700 hover:bg-green-50';
                const downButtonClass = feedback === 'down' ? 'bg-red-600 text-white font-semibold' : 'text-red-600 hover:text-red-700 hover:bg-red-50';
                
                const upButtonText = feedback === 'up' ? 'ğŸ‘ Ù…ÙÙŠØ¯ âœ“' : 'ğŸ‘ Ù…ÙÙŠØ¯';
                const downButtonText = feedback === 'down' ? 'ğŸ‘ ØºÙŠØ± Ù…ÙÙŠØ¯ âœ“' : 'ğŸ‘ ØºÙŠØ± Ù…ÙÙŠØ¯';
                
                // Store the text for TTS (strip HTML tags for clean text)
                const cleanText = text.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ').trim();
                
                feedbackDiv.innerHTML = `
                    <button onclick="submitFeedback('${sessionId}', '${messageId}', 'up')" 
                            class="${upButtonClass} px-2 py-1 rounded transition-colors duration-200" 
                            ${feedback ? 'disabled' : ''}>
                        ${upButtonText}
                    </button>
                    <button onclick="submitFeedback('${sessionId}', '${messageId}', 'down')" 
                            class="${downButtonClass} px-2 py-1 rounded transition-colors duration-200" 
                            ${feedback ? 'disabled' : ''}>
                        ${downButtonText}
                    </button>
                    <button onclick="speakTextFromButton(this)" 
                            class="text-blue-600 hover:text-blue-700 hover:bg-blue-50 px-2 py-1 rounded transition-colors duration-200" 
                            title="Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù†Øµ"
                            data-text="${cleanText.replace(/"/g, '&quot;').replace(/'/g, '&#39;')}">
                        ğŸ”Š
                    </button>
                    ${feedback ? `<span class="text-sm font-bold ml-2" style="color: ${feedback === 'up' ? '#10b981' : '#ef4444'}">ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ù†Ø¬Ø§Ø­</span>` : ''}
                `;
                bubble.appendChild(feedbackDiv);
            }
            
            messageDiv.appendChild(bubble);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Hide welcome after first message
            if (welcome) welcome.style.display = 'none';
        }

        // Text-to-Speech: Simple frontend - just calls backend and plays audio
        window.currentAudio = null;
        
        window.speakTextFromButton = function(button) {
            const text = button.getAttribute('data-text');
            if (!text) return;
            
            // Decode HTML entities
            const decodedText = text
                .replace(/&quot;/g, '"')
                .replace(/&#39;/g, "'")
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>');
            
            // Stop current audio if playing
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
                button.textContent = 'ğŸ”Š';
                button.classList.remove('text-orange-600');
                button.classList.add('text-blue-600');
                return;
            }
            
            // Show loading state
            button.textContent = 'â³';
            button.disabled = true;
            
            // Call backend TTS endpoint - all TTS logic is in backend
            fetch('/api/tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: decodedText })
            })
            .then(async response => {
                if (!response.ok) {
                    // Try to get error message from server
                    let errorMsg = 'TTS request failed';
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.detail || errorData.message || errorMsg;
                    } catch (e) {
                        errorMsg = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    throw new Error(errorMsg);
                }
                return response.blob();
            })
            .then(blob => {
                // Check if blob is valid
                if (!blob || blob.size === 0) {
                    throw new Error('Received empty audio data');
                }
                
                // Simply play the audio returned from backend
                const audioUrl = URL.createObjectURL(blob);
                const audio = new Audio(audioUrl);
                window.currentAudio = audio;
                
                button.textContent = 'â¸ï¸';
                button.classList.add('text-orange-600');
                button.classList.remove('text-blue-600');
                button.disabled = false;
                
                // Reset button when audio ends
                audio.onended = () => {
                    button.textContent = 'ğŸ”Š';
                    button.classList.remove('text-orange-600');
                    button.classList.add('text-blue-600');
                    URL.revokeObjectURL(audioUrl);
                    window.currentAudio = null;
                };
                
                audio.onerror = (e) => {
                    console.error('Audio playback error:', e);
                    button.textContent = 'ğŸ”Š';
                    button.classList.remove('text-orange-600');
                    button.classList.add('text-blue-600');
                    button.disabled = false;
                    URL.revokeObjectURL(audioUrl);
                    window.currentAudio = null;
                    alert('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª. Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø§Ù„ØµÙˆØª ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ….');
                };
                
                audio.play().catch(playError => {
                    console.error('Audio play() error:', playError);
                    button.textContent = 'ğŸ”Š';
                    button.classList.remove('text-orange-600');
                    button.classList.add('text-blue-600');
                    button.disabled = false;
                    URL.revokeObjectURL(audioUrl);
                    window.currentAudio = null;
                    alert('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªØµÙØ­.');
                });
            })
            .catch(error => {
                console.error('TTS error:', error);
                button.textContent = 'ğŸ”Š';
                button.classList.remove('text-orange-600');
                button.classList.add('text-blue-600');
                button.disabled = false;
                const errorMsg = error.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù†Øµ';
                alert(`Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù†Øµ: ${errorMsg}`);
            });
        };

        // Submit feedback
        window.submitFeedback = async function(session, messageId, rating) {
            try {
                console.log(`Submitting feedback: session=${session}, messageId=${messageId}, rating=${rating}`);
                
                const response = await fetch('/api/feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: session,
                        message_id: messageId,
                        rating: rating
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Feedback submitted successfully:', result);
                    
                    // Show success message
                    alert(rating === 'up' ? 'Ø´ÙƒØ±Ø§Ù‹ Ù„ØªÙ‚ÙŠÙŠÙ…Ùƒ! ğŸ‘' : 'Ø´ÙƒØ±Ø§Ù‹ØŒ Ø³Ù†Ø­Ø§ÙˆÙ„ Ø§Ù„ØªØ­Ø³ÙŠÙ†. ğŸ‘');
                    
                    // Update the UI immediately without reload
                    updateFeedbackUI(messageId, rating);
                    
                    // Update statistics in real-time
                    await updateStatisticsDisplay(session);
                    
                    // No page reload - keep the conversation intact
                    console.log('Feedback updated successfully without page reload');
                } else {
                    let errorMessage = 'Unknown error';
                    try {
                        const error = await response.json();
                        console.error('Feedback submission failed:', error);
                        errorMessage = error.detail || error.message || 'Unknown error';
                    } catch (parseError) {
                        console.error('Could not parse error response:', parseError);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    
                    console.error('Response status:', response.status);
                    console.error('Response text:', await response.text());
                    alert(`Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: ${errorMessage}`);
                }
            } catch (error) {
                console.error('Feedback error:', error);
                alert('Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
            }
        };
        
        // Update feedback UI immediately
        function updateFeedbackUI(messageId, rating) {
            console.log(`Updating UI for message ${messageId} with rating ${rating}`);
            
            // Find the message element and update its feedback buttons
            const messageElements = document.querySelectorAll('.message');
            let found = false;
            
            messageElements.forEach((msgElement, index) => {
                const feedbackDiv = msgElement.querySelector('.mt-3.pt-3.border-t');
                if (feedbackDiv) {
                    // Check if this is the right message by looking for the message ID in the onclick handlers
                    const buttons = feedbackDiv.querySelectorAll('button');
                    let isTargetMessage = false;
                    
                    buttons.forEach(button => {
                        const onclick = button.getAttribute('onclick');
                        if (onclick && onclick.includes(messageId)) {
                            isTargetMessage = true;
                        }
                    });
                    
                    if (isTargetMessage) {
                        found = true;
                        console.log(`Found target message at index ${index}`);
                        
                        // Update button styles to show feedback was submitted
                        buttons.forEach(button => {
                            const onclick = button.getAttribute('onclick');
                            
                            // Skip speaker button - it should always remain enabled
                            if (onclick && onclick.includes('speakTextFromButton')) {
                                return; // Don't disable or modify the speaker button
                            }
                            
                            if (onclick && onclick.includes(rating)) {
                                // Highlight the clicked button
                                button.className = rating === 'up' ? 
                                    'bg-green-600 text-white px-2 py-1 rounded font-semibold' : 
                                    'bg-red-600 text-white px-2 py-1 rounded font-semibold';
                                button.disabled = true;
                                button.textContent = rating === 'up' ? 'ğŸ‘ Ù…ÙÙŠØ¯ âœ“' : 'ğŸ‘ ØºÙŠØ± Ù…ÙÙŠØ¯ âœ“';
                                button.style.cursor = 'default';
                            } else if (onclick && (onclick.includes('submitFeedback'))) {
                                // Disable the other feedback button (but not speaker button)
                                button.disabled = true;
                                button.className = 'text-gray-400 px-2 py-1 rounded cursor-not-allowed opacity-50';
                                button.style.cursor = 'not-allowed';
                            }
                        });
                        
                        // Add or update feedback status text
                        let statusText = feedbackDiv.querySelector('.text-sm.text-gray-500');
                        if (!statusText) {
                            statusText = document.createElement('span');
                            statusText.className = 'text-sm text-gray-500 ml-2';
                            feedbackDiv.appendChild(statusText);
                        }
                        statusText.textContent = 'ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ù†Ø¬Ø§Ø­';
                        statusText.style.fontWeight = 'bold';
                        statusText.style.color = rating === 'up' ? '#10b981' : '#ef4444';
                        
                        // Add a small animation to show the update
                        feedbackDiv.style.transition = 'all 0.3s ease';
                        feedbackDiv.style.backgroundColor = rating === 'up' ? '#f0fdf4' : '#fef2f2';
                        feedbackDiv.style.borderColor = rating === 'up' ? '#10b981' : '#ef4444';
                        
                        // Remove the animation after a short time
                        setTimeout(() => {
                            feedbackDiv.style.backgroundColor = '';
                            feedbackDiv.style.borderColor = '';
                        }, 2000);
                    }
                }
            });
            
            if (!found) {
                console.log(`Target message ${messageId} not found in UI`);
                console.log('Available message elements:', messageElements.length);
            } else {
                console.log(`Successfully updated UI for message ${messageId}`);
            }
        }

        // Handle form submission
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Check if already processing
            if (isProcessing) {
                console.log('Already processing, ignoring submission');
                return;
            }
            
            const message = messageInput.value.trim();
            if (!message) return;
            
            // Set processing flag immediately
            isProcessing = true;
            
            // Disable input while processing
            messageInput.disabled = true;
            messageInput.placeholder = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...';
            sendButton.disabled = true;
            sendButton.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...';
            
            // Add user message
            addMessage('user', message);
            messageInput.value = '';
            
            // Show typing indicator
            typingIndicator.classList.remove('hidden');
            
            try {
                console.log('Sending request with session_id:', sessionId, 'type:', typeof sessionId);
                const requestBody = {
                    message: message,
                    session_id: sessionId
                };
                console.log('Request body:', requestBody);
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    let errText = '';
                    try { errText = await response.text(); } catch (_) {}
                    throw new Error(`HTTP ${response.status}: ${response.statusText} ${errText}`);
                }
                const data = await response.json();
                
                // Update session ID only if it's different (shouldn't happen with our logic)
                console.log('Previous session ID:', sessionId);
                if (data.session_id && data.session_id !== sessionId) {
                    console.log('Session ID changed from server:', data.session_id);
                    sessionId = data.session_id;
                    localStorage.setItem('doha_chat_session_id', sessionId);
                } else {
                    console.log('Session ID unchanged:', sessionId);
                }
                
                // Add assistant response
                addMessage('assistant', data.answer, data.sources, data.message_id);
            } catch (error) {
                addMessage('assistant', 'Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
                console.error('Chat error:', error);
            } finally {
                // Hide typing indicator
                typingIndicator.classList.add('hidden');
                
                // Reset processing flag
                isProcessing = false;
                
                // Re-enable input after response
                messageInput.disabled = false;
                messageInput.placeholder = 'Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ Ù‡Ù†Ø§...';
                messageInput.focus();
                sendButton.disabled = false;
                sendButton.textContent = 'Ø¥Ø±Ø³Ø§Ù„';
            }
        });

        // Load conversation history if session exists
        async function loadConversationHistory() {
            if (sessionId) {
                try {
                    console.log('Loading history for session:', sessionId);
                    const response = await fetch(`/api/chat/history?session_id=${sessionId}`);
                    if (response.ok) {
                        const history = await response.json();
                        console.log('Loaded history:', history.length, 'messages');
                        // Hide welcome message if there's history
                        if (history.length > 0 && welcome) {
                            welcome.style.display = 'none';
                        }
                        // Display conversation history
                        history.forEach(msg => {
                            if (msg.role === 'user') {
                                addMessage('user', msg.text);
                            } else if (msg.role === 'assistant') {
                                addMessage('assistant', msg.text, msg.sources || [], msg.message_id, msg.feedback);
                            }
                        });
                        
                    } else {
                        console.log('No history found for session:', sessionId);
                    }
                } catch (error) {
                    console.error('Error loading conversation history:', error);
                }
            }
        }


        // Start new chat session
        function startNewChat() {
            console.log('Starting new chat session');
            sessionId = generateUUID();
            localStorage.setItem('doha_chat_session_id', sessionId);
            chatContainer.innerHTML = '';
            if (welcome) welcome.style.display = 'block';
            messageInput.focus();
            console.log('New session ID:', sessionId);
        }

        // Add new chat button to header
        document.addEventListener('DOMContentLoaded', function() {
            const header = document.querySelector('header .container');
            const newChatBtn = document.createElement('button');
            newChatBtn.textContent = 'Ù…Ø­Ø§Ø¯Ø«Ø© Ø¬Ø¯ÙŠØ¯Ø©';
            newChatBtn.className = 'bg-white bg-opacity-20 hover:bg-opacity-30 px-3 py-1 rounded text-sm ml-4';
            newChatBtn.onclick = startNewChat;
            header.appendChild(newChatBtn);
            
            // Load conversation history
            loadConversationHistory();
        });

        // Function to update statistics display in real-time
        async function updateStatisticsDisplay(sessionId) {
            if (!sessionId) {
                console.log('No session ID available for statistics update');
                return;
            }
            
            try {
                console.log(`Updating statistics display for session: ${sessionId}`);
                const response = await fetch(`/api/feedback/statistics/${sessionId}`);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Statistics updated in real-time:', result);
                    
                    // You can add a visual indicator here if needed
                    // For now, just log the updated statistics
                    const stats = result.statistics;
                    if (stats) {
                        console.log(`ğŸ“Š Real-time Stats - Positive: ${stats.positive}, Negative: ${stats.negative}, Null: ${stats.null}`);
                    }
                } else {
                    console.error('Failed to fetch updated statistics');
                }
            } catch (error) {
                console.error('Error updating statistics display:', error);
            }
        }

        // Function to recalculate statistics for current session
        window.recalculateStatistics = async function() {
            if (!sessionId) {
                console.log('No session ID available for statistics recalculation');
                return;
            }
            
            try {
                console.log(`Recalculating statistics for session: ${sessionId}`);
                const response = await fetch(`/api/feedback/statistics/${sessionId}/recalculate`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Statistics recalculated successfully:', result);
                    alert('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­!');
                } else {
                    const error = await response.json();
                    console.error('Failed to recalculate statistics:', error);
                    alert(`ÙØ´Ù„ ÙÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª: ${error.detail || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error recalculating statistics:', error);
                alert('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª');
            }
        };

        // Focus input on load
        messageInput.focus();
    </script>
</body>
</html>

